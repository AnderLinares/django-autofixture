# -*- coding: utf-8 -*-
from django.db.models import fields
from django.db.models.fields import related
from django.utils.datastructures import SortedDict
from django_autofixture import constraints, generators, signals


class CreateInstanceError(Exception):
    pass


class AutoFixture(object):
    '''
    We don't support the following fields yet:

        * ``XMLField``
        * ``FileField``
        * ``ImageField``

    Patches are welcome.
    '''
    class IGNORE_FIELD(object):
        pass

    overwrite_defaults = False
    follow_fk = True
    generate_fk = False
    follow_m2m = (1, 5)
    generate_m2m = False

    none_chance = 0.2
    tries = 1000

    field_to_generator = SortedDict((
        (fields.BooleanField, generators.BooleanGenerator),
        (fields.NullBooleanField, generators.NullBooleanGenerator),
        (fields.DateTimeField, generators.DateTimeGenerator),
        (fields.DateField, generators.DateGenerator),
        (fields.PositiveSmallIntegerField, generators.PositiveSmallIntegerGenerator),
        (fields.PositiveIntegerField, generators.PositiveIntegerGenerator),
        (fields.SmallIntegerField, generators.SmallIntegerGenerator),
        (fields.IntegerField, generators.IntegerGenerator),
        (fields.IPAddressField, generators.IPAddressGenerator),
        (fields.TextField, generators.LoremGenerator),
        (fields.TimeField, generators.TimeGenerator),
    ))

    default_constraints = [
        constraints.unique_constraint,
        constraints.unique_together_constraint]

    def __init__(self, model,
            field_values=None, none_chance=None, overwrite_defaults=None,
            constraints=None, follow_fk=None, generate_fk=None,
            follow_m2m=None, generate_m2m=None):
        '''
        Parameters:
            ``model``: 

            ``field_values``: A dictionary with field names of ``model`` as
                keys. Values may be static values that are assigned to the
                field or a ``Generator`` instance that generates a value on the
                fly.

            ``none_chance``: The chance (between 0 and 1, 1 equals 100%) to
            assign ``None`` to nullable fields.

            ``overwrite_defaults``: All default values of fields are preserved
                by default. If set to ``True``, default values will be
                generated by a matching ``Generator``.

            ``constraints``: A list of callables. The constraints are used to
                verify if the created model instance may be used. The callable
                gets the actual model as first and the instance as second
                parameter. The instance is not populated yet at this moment.
                The callable may raise an ``InvalidConstraint`` exception to
                indicate which fields violate the constraint.

            ``follow_fk``: A boolean value indicating if foreign keys should be
                set to random, already existing, instances of the related
                model. Default is ``True``.

            ``generate_fk``: A boolean which indicates if related models should
                also be created with random values. Default is ``False``. The
                ``follow_fk`` parameter will be ignored if this one is set to
                ``True``.

            ``follow_m2m``: A tuple containing minium and maximum of model
                instances that are assigned to ``ManyToManyField``. No new
                instances will be created. Default is (1, 5).
                You can ignore ``ManyToManyField`` fields by setting this
                parameter to ``False``.

            ``generate_m2m``: A tuple containing minimum and maximum number of
                model instance that are newly created and assigned to the
                ``ManyToManyField``. Default is ``False`` which disables the
                generation of new related instances. The value of
                ``follow_m2m`` will be ignored if this parameter is set.
        '''
        self.model = model
        self.field_values = field_values or {}
        self.constraints = constraints or []
        if none_chance is not None:
            self.none_chance = none_chance
        if overwrite_defaults is not None:
            self.overwrite_defaults = overwrite_defaults
        if follow_fk is not None:
            self.follow_fk = follow_fk
        if generate_fk is not None:
            self.generate_fk = generate_fk
        if follow_m2m is not None:
            self.follow_m2m = follow_m2m
        if generate_m2m is not None:
            self.generate_m2m = generate_m2m

        for constraint in self.default_constraints:
            self.add_constraint(constraint)

        self._field_generators = {}

    def add_constraint(self, constraint):
        self.constraints.append(constraint)

    def add_field_value(self, name, value):
        self.field_values[name] = value

    def get_generator(self, field):
        '''
        Return a value generator based on the field instance that is passed to
        this method. This function may return ``None`` which means that the
        specified field will be ignored (e.g. if no matching generator was
        found).
        '''
        if isinstance(field, fields.AutoField):
            return None
        if field.default is not fields.NOT_PROVIDED and \
            not self.overwrite_defaults:
                return None
        kwargs = {}

        if field.name in self.field_values:
            value = self.field_values[field.name]
            if isinstance(value, generators.Generator):
                return value
            elif isinstance(value, AutoFixture):
                return generators.InstanceGenerator(autofixture=value)
            return generators.StaticGenerator(value=value)

        if field.null:
            kwargs['none_chance'] = self.none_chance
        if field.choices:
            return generators.ChoicesGenerator(choices=field.choices, **kwargs)
        if isinstance(field, related.ForeignKey):
            # if generate_fk is set, follow_fk is ignored.
            if self.generate_fk:
                return generators.InstanceGenerator(
                    AutoFixture(field.rel.to),
                    limit_choices_to=field.rel.limit_choices_to)
            elif self.follow_fk:
                return generators.InstanceSelector(
                    field.rel.to,
                    limit_choices_to=field.rel.limit_choices_to)
            elif field.null:
                return generators.NoneGenerator()
            raise CreateInstanceError(
                u'Cannot resolve ForeignKey "%s" to "%s". Provide either '
                u'"follow_fk" or "generate_fk" parameters.' % (
                    field.name,
                    '%s.%s' % (
                        field.rel.to._meta.app_label,
                        field.rel.to._meta.object_name,
                    )
            ))
        if isinstance(field, related.ManyToManyField):
            if self.generate_m2m:
                min_count, max_count = self.generate_m2m[0:2]
                return generators.MultipleInstanceGenerator(
                    AutoFixture(field.rel.to),
                    limit_choices_to=field.rel.limit_choices_to,
                    min_count=min_count,
                    max_count=max_count,
                    **kwargs)
            elif self.follow_m2m:
                min_count, max_count = self.follow_m2m[0:2]
                return generators.InstanceSelector(
                    field.rel.to,
                    limit_choices_to=field.rel.limit_choices_to,
                    min_count=min_count,
                    max_count=max_count,
                    **kwargs)
            elif field.null:
                return generators.NoneGenerator()
            raise CreateInstanceError(
                u'Cannot assign instances of "%s" to ManyToManyField "%s". '
                u'Provide either "follow_m2m" or "generate_m2m" '
                u'parameters.' % (
                    '%s.%s' % (
                        field.rel.to._meta.app_label,
                        field.rel.to._meta.object_name,
                    ),
                    field.name,
            ))
        if isinstance(field, fields.FilePathField):
            return generators.FilePathGenerator(
                path=field.path, match=field.match, recursive=field.recursive,
                max_length=field.max_length, **kwargs)
        if isinstance(field, fields.CharField):
            if isinstance(field, fields.SlugField):
                generator = generators.SlugGenerator
            elif isinstance(field, fields.EmailField):
                generator = generators.EmailGenerator
            elif isinstance(field, fields.URLField):
                generator = generators.URLGenerator
            elif field.max_length > 15:
                return generators.LoremSentenceGenerator(
                    common=False,
                    max_length=field.max_length)
                generator = generators.StringGenerator
            return generator(max_length=field.max_length)
        if isinstance(field, fields.DecimalField):
            return generators.DecimalGenerator(
                decimal_places=field.decimal_places,
                max_digits=field.max_digits)
        if hasattr(fields, 'BigIntegerField'):
            if isinstance(field, fields.BigIntegerField):
                return generators.IntegerGenerator(
                    min_value=-field.MAX_BIGINT - 1,
                    max_value=field.MAX_BIGINT,
                    **kwargs)
        for field_class, generator in self.field_to_generator.items():
            if isinstance(field, field_class):
                return generator(**kwargs)
        return None

    def get_value(self, field):
        '''
        Return a random value that can be assigned to the passed field
        instance.
        '''
        if field not in self._field_generators:
            self._field_generators[field] = self.get_generator(field)
        generator = self._field_generators[field]
        if generator is None:
            return self.IGNORE_FIELD
        value = generator.get_value()
        return value

    def process_field(self, instance, field):
        value = self.get_value(field)
        if value is self.IGNORE_FIELD:
            return
        setattr(instance, field.name, value)

    def process_m2m(self, instance, field):
        return self.process_field(instance, field)

    def check_constrains(self, instance):
        '''
        Return fieldnames which need recalculation.
        '''
        recalc_fields = []
        for constraint in self.constraints:
            try:
                constraint(self.model, instance)
            except constraints.InvalidConstraint, e:
                recalc_fields.extend(e.fields)
        return recalc_fields

    def create_one(self, commit=True):
        tries = self.tries
        instance = self.model()
        process = instance._meta.fields
        while process and tries > 0:
            for field in process:
                self.process_field(instance, field)
            process = self.check_constrains(instance)
            tries -= 1
        if tries == 0:
            raise CreateInstanceError(
                u'Cannot solve constraints for "%s", tried %d times. '
                u'Please check value generators or model constraints.'
                u'At least the following fields are involved: %s' % (
                    '%s.%s' % (
                        self.model._meta.app_label,
                        self.model._meta.object_name),
                    self.tries,
                    ', '.join([field.name for field in process]),
            ))
        if commit:
            instance.save()
            for field in instance._meta.many_to_many:
                self.process_m2m(instance, field)
        signals.instance_created.send(
            sender=self,
            model=self.model,
            instance=instance,
            commited=commit)
        return instance

    def create(self, count=1, commit=True):
        '''
        Create and return ``count`` model instances.

        May raise ``CreateInstanceError`` if constraints are not satisfied.
        '''
        object_list = []
        for i in xrange(count):
            instance = self.create_one(commit=commit)
            object_list.append(instance)
        return object_list

    def iter(self, count=1, commit=True):
        for i in xrange(count):
            yield self.create_one(commit=commit)

    def __iter__(self):
        yield self.create_one()
