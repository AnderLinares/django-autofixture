# -*- coding: utf-8 -*-
from django.db.models import fields
from django.utils.datastructures import SortedDict
from django_testdata import generators


class CreateInstanceError(Exception):
    pass


class AutoFixture(object):
    '''
    We don't support the following fields atm:

        * Related fields (``ForeingKey`` etc.)
        * File fields
        * ``FilePathField``
        * ``TimeField``
        * ``URLField``
        * ``XMLField``

    We plan to support any field expect the ``XMLField``. Patches are welcome.
    '''
    class CONTINUE(object):
        pass

    overwrite_defaults = False
    follow_fks = False
    generate_fks = False

    none_chance = 0.2
    tries = 1000

    field_to_generator = SortedDict((
        (fields.BooleanField, generators.BooleanGenerator),
        (fields.NullBooleanField, generators.NullBooleanGenerator),
        (fields.DateTimeField, generators.DateTimeGenerator),
        (fields.DateField, generators.DateGenerator),
        (fields.PositiveSmallIntegerField, generators.PositiveSmallIntegerGenerator),
        (fields.PositiveIntegerField, generators.PositiveIntegerGenerator),
        (fields.SmallIntegerField, generators.SmallIntegerGenerator),
        (fields.IntegerField, generators.IntegerGenerator),
        (fields.IPAddressField, generators.IPAddressGenerator),
        (fields.TextField, generators.LoremGenerator),
    ))

    def __init__(self, model,
            field_values=None, none_chance=None,
            overwrite_defaults=None, follow_fks=None, generate_fks=None):
        '''
        Parameters:
            ``model``: 

            ``field_values``: A dictionary with field names of ``model`` as
                keys. Values may be static values that are assigned to the
                field or a ``Generator`` instance that generates a value on the
                fly.

            ``overwrite_defaults``: All default values of fields are preserved
                by default. If set to ``True``, default values will be
                generated by a matching ``Generator``.
        '''
        self.model = model
        self.field_values = field_values or {}
        if none_chance is not None:
            self.none_chance = none_chance
        if overwrite_defaults is not None:
            self.overwrite_defaults = overwrite_defaults
        if follow_fks is not None:
            self.follow_fks = follow_fks
        if generate_fks is not None:
            self.generate_fks = generate_fks

    def get_generator(self, field):
        '''
        Get a field and return value generator.
        To ignore the field, return ``None``.
        '''
        if isinstance(field, fields.AutoField):
            return None
        if field.default is not fields.NOT_PROVIDED and \
            not self.overwrite_defaults:
                return None
        kwargs = {}
        if field.null:
            kwargs['none_chance'] = self.none_chance
        if field.choices:
            return generators.ChoicesGenerator(choices=field.choices, **kwargs)
        elif isinstance(field, fields.EmailField):
            return generators.EmailGenerator(max_length=field.max_length, **kwargs)
        elif isinstance(field, fields.CharField):
            if field.blank:
                min_length = 0
            else:
                min_length = 1
            if isinstance(field, fields.SlugField):
                generator = generators.SlugGenerator
            else:
                generator = generators.StringGenerator
            return generator(
                min_length=min_length,
                max_length=field.max_length)
        elif isinstance(field, fields.DecimalField):
            return generators.DecimalGenerator(
                decimal_places=field.decimal_places,
                max_digits=field.max_digits)
        if hasattr(fields, 'BigIntegerField'):
            if isinstance(field, fields.BigIntegerField):
                return generators.IntegerGenerator(
                    min_value=-field.MAX_BIGINT - 1,
                    max_value=field.MAX_BIGINT,
                    **kwargs)
        for field_class, generator in self.field_to_generator.items():
            if isinstance(field, field_class):
                return generator(**kwargs)
        return None

    def get_value(self, field):
        generator = self.get_generator(field)
        if generator is None:
            return self.CONTINUE
        value = generator.get_value()
        return value

    def process_field(self, instance, field):
        value = self.get_value(field)
        if value is self.CONTINUE:
            return
        setattr(instance, field.name, value)

    def is_unique(self, lookups):
        return not bool(
                self.model._default_manager.filter(**lookups))

    def check_constrains(self, instance):
        '''
        Return field names which need recalculation.
        '''
        for field in instance._meta.fields:
            if field.unique:
                unique = self.is_unique(
                    {field.name: getattr(instance, field.name)})
                if not unique:
                    return (field,)
        if instance._meta.unique_together:
            for fields in instance._meta.unique_together:
                check = {}
                for field_name in fields:
                    check[field_name] = getattr(instance, field_name)
                if not self.is_unique(check):
                    return [instance._meta.get_field_by_name(field_name)[0]
                        for field_name in fields]
        return ()

    def create(self, count=1, commit=True):
        '''
        Create and return ``count`` model instances.
        '''
        object_list = []
        for i in xrange(count):
            tries = self.tries
            instance = self.model()
            process = instance._meta.fields
            while process and tries > 0:
                for field in process:
                    self.process_field(instance, field)
                process = self.check_constrains(instance)
                tries -= 1
            if tries == 0:
                raise CreateInstanceError(
                    u'Cannot solve constraints for "%s", tried %d times. '
                    u'Please check value generators or model constraints.' % (
                        '%s.%s' % (
                            self.model._meta.app_label,
                            self.model._meta.object_name),
                        self.tries,
                ))
            if commit:
                instance.save()
            object_list.append(instance)
        return object_list
